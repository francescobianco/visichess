<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VisiChess - Allenamento Visualizzazione Scacchistica</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .back-btn-top {
            display: block;
            max-width: 1200px;
            margin: 0 auto 20px auto;
            padding: 10px 20px;
            background: #666;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            width: fit-content;
        }

        .back-btn-top:hover {
            background: #555;
        }

        h1 {
            text-align: center;
            color: #1e3c72;
            margin-bottom: 20px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .info-panel {
            background: #f0f4ff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
        }

        .info-panel h3 {
            color: #1e3c72;
            margin-bottom: 15px;
        }

        .exercise-types {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .exercise-type {
            background: white;
            padding: 12px;
            border-radius: 8px;
            border-left: 4px solid #2a5298;
        }

        .exercise-type-title {
            font-weight: bold;
            color: #1e3c72;
            margin-bottom: 5px;
        }

        .exercise-type-desc {
            font-size: 0.9em;
            color: #666;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 10px;
            margin-top: 30px;
        }

        .level-cell {
            aspect-ratio: 1;
            border: 2px solid #ddd;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);
            position: relative;
        }

        .level-cell:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .level-cell.completed {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border-color: #4CAF50;
        }

        .level-cell.high-progress {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: white;
            border-color: #2196F3;
        }

        .level-cell.low-progress {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
            color: white;
            border-color: #f44336;
        }

        .level-cell.in-progress {
            background: linear-gradient(135deg, #FFC107 0%, #FFB300 100%);
            color: white;
            border-color: #FFC107;
        }

        .level-cell.current {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: white;
            border-color: #2196F3;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(33, 150, 243, 0.7); }
            50% { box-shadow: 0 0 0 10px rgba(33, 150, 243, 0); }
        }

        .level-number {
            font-size: 1.5em;
            font-weight: bold;
        }

        .level-score {
            font-size: 0.8em;
            margin-top: 5px;
        }

        .exercise-view {
            display: none;
        }

        .exercise-view.active {
            display: block;
        }

        .exercise-header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .back-btn {
            padding: 10px 20px;
            background: #666;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
        }

        .back-btn:hover {
            background: #555;
        }

        .progress-info {
            text-align: center;
        }

        .exercise-content {
            background: #f9f9f9;
            padding: 40px;
            border-radius: 10px;
            margin-bottom: 30px;
            min-height: 300px;
        }

        .question {
            font-size: 1.5em;
            text-align: center;
            margin-bottom: 30px;
            color: #1e3c72;
        }

        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            max-width: 400px;
            margin: 30px auto;
            border: 3px solid #333;
        }

        .square {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            cursor: pointer;
            transition: background 0.2s;
        }

        .square.light {
            background: #f0d9b5;
        }

        .square.dark {
            background: #b58863;
        }

        .square:hover {
            opacity: 0.8;
        }

        .square.selected {
            box-shadow: inset 0 0 0 3px #2196F3;
        }

        .answers {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 30px;
        }

        .answer-btn {
            padding: 15px 30px;
            font-size: 1.2em;
            border: 2px solid #2a5298;
            background: white;
            color: #2a5298;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .answer-btn:hover {
            background: #2a5298;
            color: white;
        }

        .input-answer {
            padding: 15px;
            font-size: 1.2em;
            border: 2px solid #2a5298;
            border-radius: 8px;
            text-align: center;
            max-width: 200px;
        }

        .submit-btn {
            padding: 15px 40px;
            font-size: 1.2em;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-left: 15px;
        }

        .submit-btn:hover {
            background: #45a049;
        }

        .feedback {
            text-align: center;
            font-size: 1.3em;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .feedback.correct {
            background: #d4edda;
            color: #155724;
        }

        .feedback.incorrect {
            background: #f8d7da;
            color: #721c24;
        }

        .next-btn {
            display: block;
            margin: 20px auto 0;
            padding: 15px 40px;
            font-size: 1.2em;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }

        .next-btn:hover {
            background: #1976D2;
        }

        .completion-summary {
            text-align: center;
            padding: 40px;
        }

        .completion-summary h2 {
            color: #4CAF50;
            font-size: 2em;
            margin-bottom: 20px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-item {
            background: #f0f4ff;
            padding: 20px;
            border-radius: 10px;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #2a5298;
        }

        .stat-label {
            color: #666;
            margin-top: 5px;
        }

        .challenge-section {
            margin-top: 50px;
            padding: 30px;
            background: #f0f4ff;
            border-radius: 10px;
        }

        .challenge-section h3 {
            color: #1e3c72;
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.8em;
        }

        .challenge-chart {
            display: flex;
            align-items: flex-end;
            justify-content: space-between;
            gap: 4px;
            height: 200px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            overflow: visible;
        }

        .day-bar {
            flex: 1;
            min-width: 8px;
            background: linear-gradient(to top, #2a5298, #4CAF50);
            border-radius: 3px 3px 0 0;
            position: relative;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .day-bar:hover {
            opacity: 0.7;
        }

        .day-bar.empty {
            background: #e0e0e0;
            opacity: 0.5;
        }

        .day-bar-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8em;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            margin-bottom: 5px;
        }

        .day-bar:hover .day-bar-tooltip {
            opacity: 1;
        }

        .challenge-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .challenge-stat {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .challenge-stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #2a5298;
        }

        .challenge-stat-label {
            color: #666;
            margin-top: 5px;
            font-size: 0.9em;
        }

        .footer {
            max-width: 1200px;
            margin: 20px auto 0;
            text-align: center;
            padding: 20px;
        }

        .reset-btn {
            padding: 12px 30px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .reset-btn:hover {
            background: #d32f2f;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <button class="back-btn-top" id="backButtonTop" style="display: none;" onclick="goHome()">‚Üê Torna alla Home</button>

    <div class="container">
        <!-- Home View -->
        <div id="homeView">
            <h1>üéØ VisiChess</h1>
            <p class="subtitle">Allenamento Progressivo per la Visualizzazione Scacchistica</p>

            <div class="info-panel">
                <h3>üìö Tipologie di Esercizi nel Sistema</h3>
                <p>Il sistema include <strong>8 tipologie</strong> di esercizi progressivi che ti porteranno dalla base alla completa visualizzazione:</p>
                <div class="exercise-types">
                    <div class="exercise-type">
                        <div class="exercise-type-title">1. Riconoscimento Caselle</div>
                        <div class="exercise-type-desc">Identifica il colore delle case sulla scacchiera</div>
                    </div>
                    <div class="exercise-type">
                        <div class="exercise-type-title">2. Coordinate</div>
                        <div class="exercise-type-desc">Memorizza e trova le coordinate delle case</div>
                    </div>
                    <div class="exercise-type">
                        <div class="exercise-type-title">3. Movimento Pezzi</div>
                        <div class="exercise-type-desc">Visualizza dove pu√≤ muovere un pezzo</div>
                    </div>
                    <div class="exercise-type">
                        <div class="exercise-type-title">4. Sequenze Mosse</div>
                        <div class="exercise-type-desc">Segui sequenze di mosse senza scacchiera</div>
                    </div>
                    <div class="exercise-type">
                        <div class="exercise-type-title">5. Diagonali e Linee</div>
                        <div class="exercise-type-desc">Riconosci pattern geometrici sulla scacchiera</div>
                    </div>
                    <div class="exercise-type">
                        <div class="exercise-type-title">6. Calcolo Tattico</div>
                        <div class="exercise-type-desc">Calcola tattiche semplici mentalmente</div>
                    </div>
                    <div class="exercise-type">
                        <div class="exercise-type-title">7. Varianti</div>
                        <div class="exercise-type-desc">Analizza varianti multiple a mente</div>
                    </div>
                    <div class="exercise-type">
                        <div class="exercise-type-title">8. Scacchi alla Cieca</div>
                        <div class="exercise-type-desc">Gioca partite complete senza vedere la scacchiera</div>
                    </div>
                </div>
            </div>

            <h3 style="text-align: center; color: #1e3c72; margin-bottom: 20px;">Scegli il tuo livello (1 = facile ‚Üí 64 = maestro)</h3>

            <div class="grid-container" id="levelGrid"></div>

            <!-- 30 Day Challenge Section -->
            <div class="challenge-section">
                <h3>üî• La Sfida dei 30 Giorni</h3>
                <div class="challenge-chart" id="challengeChart"></div>
                <div class="challenge-stats">
                    <div class="challenge-stat">
                        <div class="challenge-stat-value" id="currentStreak">0</div>
                        <div class="challenge-stat-label">Serie Attuale</div>
                    </div>
                    <div class="challenge-stat">
                        <div class="challenge-stat-value" id="bestStreak">0</div>
                        <div class="challenge-stat-label">Serie Migliore</div>
                    </div>
                    <div class="challenge-stat">
                        <div class="challenge-stat-value" id="totalDays">0</div>
                        <div class="challenge-stat-label">Giorni Attivi</div>
                    </div>
                    <div class="challenge-stat">
                        <div class="challenge-stat-value" id="totalCorrect">0</div>
                        <div class="challenge-stat-label">Risposte Corrette</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Exercise View -->
        <div id="exerciseView" class="exercise-view">
            <div class="exercise-header">
                <h2>Livello <span id="currentLevel"></span></h2>
                <p>Esercizio <span id="currentExercise"></span> di <span id="totalExercises"></span></p>
            </div>

            <div class="exercise-content" id="exerciseContent"></div>

            <div id="completionView" style="display: none;">
                <div class="completion-summary">
                    <h2>‚úÖ Livello Completato!</h2>
                    <div class="stats">
                        <div class="stat-item">
                            <div class="stat-value" id="finalScore">0%</div>
                            <div class="stat-label">Punteggio</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="correctAnswers">0</div>
                            <div class="stat-label">Risposte Corrette</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="totalTime">0s</div>
                            <div class="stat-label">Tempo Totale</div>
                        </div>
                    </div>
                    <button class="next-btn" onclick="goHome()">Torna alla Home</button>
                </div>
            </div>
        </div>
    </div>

    <div class="footer" id="footer">
        <button class="reset-btn" onclick="resetAllProgress()">üîÑ Resetta Tutti i Risultati</button>
    </div>

    <script>
        // Configuration
        const EXERCISES_PER_LEVEL = 5;

        // Exercise types with difficulty scaling
        const EXERCISE_TYPES = {
            SQUARE_COLOR: 'square_color',
            COORDINATES: 'coordinates',
            PIECE_MOVEMENT: 'piece_movement',
            MOVE_SEQUENCE: 'move_sequence',
            DIAGONALS: 'diagonals',
            TACTICAL: 'tactical',
            VARIANTS: 'variants',
            BLINDFOLD: 'blindfold'
        };

        // Global state
        let currentLevel = 1;
        let currentExerciseIndex = 0;
        let exercises = [];
        let correctCount = 0;
        let startTime = null;
        let answerSubmitted = false;

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            renderLevelGrid();
            loadProgress();
            render30DayChallenge();
        });

        function renderLevelGrid() {
            const grid = document.getElementById('levelGrid');
            grid.innerHTML = '';

            for (let i = 1; i <= 64; i++) {
                const cell = document.createElement('div');
                cell.className = 'level-cell';

                const progress = getLevelProgress(i);
                if (progress.score === 100) {
                    cell.classList.add('completed');
                } else if (progress.score >= 80) {
                    cell.classList.add('high-progress');
                } else if (progress.score > 0) {
                    cell.classList.add('low-progress');
                }

                const nextLevel = getNextRecommendedLevel();
                if (i === nextLevel) {
                    cell.classList.add('current');
                }

                cell.innerHTML = `
                    <div class="level-number">${i}</div>
                    <div class="level-score">${progress.score}%</div>
                `;

                cell.onclick = () => startLevel(i);
                grid.appendChild(cell);
            }
        }

        function getLevelProgress(level) {
            const key = `level_${level}`;
            const data = sessionStorage.getItem(key);
            return data ? JSON.parse(data) : { score: 0, completed: false };
        }

        function saveLevelProgress(level, score) {
            const key = `level_${level}`;
            sessionStorage.setItem(key, JSON.stringify({
                score: score,
                completed: score === 100,
                timestamp: new Date().toISOString()
            }));
        }

        function getNextRecommendedLevel() {
            for (let i = 1; i <= 64; i++) {
                const progress = getLevelProgress(i);
                if (progress.score < 100) {
                    return i;
                }
            }
            return 64;
        }

        function loadProgress() {
            // Progress is loaded from sessionStorage when rendering grid
        }

        function startLevel(level) {
            currentLevel = level;
            currentExerciseIndex = 0;
            correctCount = 0;
            startTime = Date.now();

            exercises = generateExercisesForLevel(level);

            document.getElementById('homeView').style.display = 'none';
            document.getElementById('exerciseView').classList.add('active');
            document.getElementById('completionView').style.display = 'none';
            document.getElementById('exerciseContent').style.display = 'block';
            document.getElementById('footer').style.display = 'none'; // Hide reset button during quiz
            document.getElementById('backButtonTop').style.display = 'block'; // Show back button

            showExercise();
        }

        function generateExercisesForLevel(level) {
            const exercises = [];
            const difficulty = Math.ceil(level / 8); // 1-8 difficulty tiers

            // Mix of exercise types based on level
            const mix = getExerciseMix(level);

            for (let i = 0; i < EXERCISES_PER_LEVEL; i++) {
                const type = mix[i % mix.length];
                exercises.push(generateExercise(type, difficulty, level));
            }

            return exercises;
        }

        function getExerciseMix(level) {
            // Progressive mix of exercises
            if (level <= 8) {
                return [EXERCISE_TYPES.SQUARE_COLOR, EXERCISE_TYPES.COORDINATES, EXERCISE_TYPES.SQUARE_COLOR, EXERCISE_TYPES.COORDINATES];
            } else if (level <= 16) {
                return [EXERCISE_TYPES.COORDINATES, EXERCISE_TYPES.PIECE_MOVEMENT, EXERCISE_TYPES.SQUARE_COLOR, EXERCISE_TYPES.DIAGONALS];
            } else if (level <= 24) {
                return [EXERCISE_TYPES.PIECE_MOVEMENT, EXERCISE_TYPES.MOVE_SEQUENCE, EXERCISE_TYPES.DIAGONALS, EXERCISE_TYPES.COORDINATES];
            } else if (level <= 32) {
                return [EXERCISE_TYPES.MOVE_SEQUENCE, EXERCISE_TYPES.DIAGONALS, EXERCISE_TYPES.PIECE_MOVEMENT, EXERCISE_TYPES.TACTICAL];
            } else if (level <= 40) {
                return [EXERCISE_TYPES.MOVE_SEQUENCE, EXERCISE_TYPES.TACTICAL, EXERCISE_TYPES.VARIANTS, EXERCISE_TYPES.DIAGONALS];
            } else if (level <= 48) {
                return [EXERCISE_TYPES.TACTICAL, EXERCISE_TYPES.VARIANTS, EXERCISE_TYPES.MOVE_SEQUENCE, EXERCISE_TYPES.BLINDFOLD];
            } else if (level <= 56) {
                return [EXERCISE_TYPES.VARIANTS, EXERCISE_TYPES.BLINDFOLD, EXERCISE_TYPES.TACTICAL, EXERCISE_TYPES.MOVE_SEQUENCE];
            } else {
                return [EXERCISE_TYPES.BLINDFOLD, EXERCISE_TYPES.VARIANTS, EXERCISE_TYPES.TACTICAL, EXERCISE_TYPES.BLINDFOLD];
            }
        }

        function generateExercise(type, difficulty, level) {
            const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            const ranks = ['1', '2', '3', '4', '5', '6', '7', '8'];

            switch(type) {
                case EXERCISE_TYPES.SQUARE_COLOR:
                    return generateSquareColorExercise(files, ranks, difficulty);
                case EXERCISE_TYPES.COORDINATES:
                    return generateCoordinatesExercise(files, ranks, difficulty);
                case EXERCISE_TYPES.PIECE_MOVEMENT:
                    return generatePieceMovementExercise(files, ranks, difficulty);
                case EXERCISE_TYPES.MOVE_SEQUENCE:
                    return generateMoveSequenceExercise(files, ranks, difficulty, level);
                case EXERCISE_TYPES.DIAGONALS:
                    return generateDiagonalsExercise(files, ranks, difficulty);
                case EXERCISE_TYPES.TACTICAL:
                    return generateTacticalExercise(files, ranks, difficulty, level);
                case EXERCISE_TYPES.VARIANTS:
                    return generateVariantsExercise(files, ranks, difficulty, level);
                case EXERCISE_TYPES.BLINDFOLD:
                    return generateBlindfoldExercise(files, ranks, difficulty, level);
                default:
                    return generateSquareColorExercise(files, ranks, difficulty);
            }
        }

        function generateSquareColorExercise(files, ranks, difficulty) {
            const file = files[Math.floor(Math.random() * files.length)];
            const rank = ranks[Math.floor(Math.random() * ranks.length)];
            const square = file + rank;

            const fileIndex = files.indexOf(file);
            const rankNumeric = parseInt(rank);
            const isLight = (fileIndex + rankNumeric) % 2 === 0;

            return {
                type: EXERCISE_TYPES.SQUARE_COLOR,
                question: `Di che colore √® la casa ${square}?`,
                answer: isLight ? 'chiara' : 'scura',
                options: ['chiara', 'scura'],
                explanation: `La casa ${square} √® ${isLight ? 'chiara' : 'scura'}`
            };
        }

        function generateCoordinatesExercise(files, ranks, difficulty) {
            if (difficulty <= 2) {
                // Show board, ask to click square
                const file = files[Math.floor(Math.random() * files.length)];
                const rank = ranks[Math.floor(Math.random() * ranks.length)];
                const square = file + rank;

                return {
                    type: EXERCISE_TYPES.COORDINATES,
                    question: `Clicca sulla casa ${square}`,
                    answer: square,
                    showBoard: true,
                    explanation: `La casa ${square} si trova qui`
                };
            } else {
                // Mental visualization
                const file = files[Math.floor(Math.random() * files.length)];
                const rank = ranks[Math.floor(Math.random() * ranks.length)];
                const square = file + rank;

                const fileIndex = files.indexOf(file);
                const rankNumeric = parseInt(rank);
                const isLight = (fileIndex + rankNumeric) % 2 === 0;

                return {
                    type: EXERCISE_TYPES.COORDINATES,
                    question: `Visualizza la casa ${square}. Di che colore √®?`,
                    answer: isLight ? 'chiara' : 'scura',
                    options: ['chiara', 'scura'],
                    explanation: `La casa ${square} √® ${isLight ? 'chiara' : 'scura'}`
                };
            }
        }

        function generatePieceMovementExercise(files, ranks, difficulty) {
            const pieces = difficulty <= 3 ? ['Torre', 'Alfiere'] : ['Torre', 'Alfiere', 'Cavallo', 'Donna'];
            const piece = pieces[Math.floor(Math.random() * pieces.length)];

            const fromFile = files[Math.floor(Math.random() * files.length)];
            const fromRank = ranks[Math.floor(Math.random() * ranks.length)];
            const fromSquare = fromFile + fromRank;

            const possibleMoves = getPossibleMoves(piece, fromSquare, files, ranks);
            const correctMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];

            // Generate wrong options
            const wrongMoves = [];
            while (wrongMoves.length < 3) {
                const file = files[Math.floor(Math.random() * files.length)];
                const rank = ranks[Math.floor(Math.random() * ranks.length)];
                const square = file + rank;
                if (!possibleMoves.includes(square) && !wrongMoves.includes(square) && square !== fromSquare) {
                    wrongMoves.push(square);
                }
            }

            const options = [correctMove, ...wrongMoves].sort(() => Math.random() - 0.5);

            return {
                type: EXERCISE_TYPES.PIECE_MOVEMENT,
                question: `Se ${piece} √® in ${fromSquare}, quale di queste case pu√≤ raggiungere?`,
                answer: correctMove,
                options: options,
                explanation: `${piece} da ${fromSquare} pu√≤ andare in ${correctMove}`
            };
        }

        function getPossibleMoves(piece, square, files, ranks) {
            const fileIndex = files.indexOf(square[0]);
            const rankIndex = ranks.indexOf(square[1]);
            const moves = [];

            if (piece === 'Torre') {
                // Horizontal and vertical
                for (let i = 0; i < 8; i++) {
                    if (i !== fileIndex) moves.push(files[i] + square[1]);
                    if (i !== rankIndex) moves.push(square[0] + ranks[i]);
                }
            } else if (piece === 'Alfiere') {
                // Diagonals
                for (let i = -7; i <= 7; i++) {
                    if (i === 0) continue;
                    const f1 = fileIndex + i;
                    const r1 = rankIndex + i;
                    const f2 = fileIndex + i;
                    const r2 = rankIndex - i;
                    if (f1 >= 0 && f1 < 8 && r1 >= 0 && r1 < 8) {
                        moves.push(files[f1] + ranks[r1]);
                    }
                    if (f2 >= 0 && f2 < 8 && r2 >= 0 && r2 < 8) {
                        moves.push(files[f2] + ranks[r2]);
                    }
                }
            } else if (piece === 'Cavallo') {
                const knightMoves = [
                    [2, 1], [2, -1], [-2, 1], [-2, -1],
                    [1, 2], [1, -2], [-1, 2], [-1, -2]
                ];
                knightMoves.forEach(([df, dr]) => {
                    const f = fileIndex + df;
                    const r = rankIndex + dr;
                    if (f >= 0 && f < 8 && r >= 0 && r < 8) {
                        moves.push(files[f] + ranks[r]);
                    }
                });
            } else if (piece === 'Donna') {
                // Combination of Torre and Alfiere
                return [...getPossibleMoves('Torre', square, files, ranks),
                        ...getPossibleMoves('Alfiere', square, files, ranks)];
            }

            return moves;
        }

        function generateMoveSequenceExercise(files, ranks, difficulty, level) {
            const moveCount = Math.min(2 + Math.floor(level / 10), 6);
            const piece = level < 25 ? 'Re' : (Math.random() < 0.5 ? 'Re' : 'Cavallo');

            let square = files[Math.floor(Math.random() * 4) + 2] + ranks[Math.floor(Math.random() * 4) + 2];
            const moves = [square];

            for (let i = 0; i < moveCount; i++) {
                const fileIndex = files.indexOf(square[0]);
                const rankIndex = ranks.indexOf(square[1]);

                if (piece === 'Re') {
                    const directions = [
                        [1, 0], [-1, 0], [0, 1], [0, -1],
                        [1, 1], [1, -1], [-1, 1], [-1, -1]
                    ];
                    const [df, dr] = directions[Math.floor(Math.random() * directions.length)];
                    const newF = Math.max(0, Math.min(7, fileIndex + df));
                    const newR = Math.max(0, Math.min(7, rankIndex + dr));
                    square = files[newF] + ranks[newR];
                } else {
                    const knightMoves = [
                        [2, 1], [2, -1], [-2, 1], [-2, -1],
                        [1, 2], [1, -2], [-1, 2], [-1, -2]
                    ];
                    const validMoves = knightMoves
                        .map(([df, dr]) => [fileIndex + df, rankIndex + dr])
                        .filter(([f, r]) => f >= 0 && f < 8 && r >= 0 && r < 8);

                    if (validMoves.length > 0) {
                        const [newF, newR] = validMoves[Math.floor(Math.random() * validMoves.length)];
                        square = files[newF] + ranks[newR];
                    }
                }
                moves.push(square);
            }

            const sequence = moves.join(' ‚Üí ');
            const finalSquare = moves[moves.length - 1];

            return {
                type: EXERCISE_TYPES.MOVE_SEQUENCE,
                question: `Segui questa sequenza del ${piece}: ${sequence}. In che casa finisce?`,
                answer: finalSquare,
                inputType: 'text',
                explanation: `Il ${piece} finisce in ${finalSquare}`
            };
        }

        function generateDiagonalsExercise(files, ranks, difficulty) {
            const file = files[Math.floor(Math.random() * files.length)];
            const rank = ranks[Math.floor(Math.random() * ranks.length)];
            const square = file + rank;

            const fileIndex = files.indexOf(file);
            const rankIndex = ranks.indexOf(rank);

            // Count diagonal squares
            let count = 0;
            for (let i = -7; i <= 7; i++) {
                if (i === 0) continue;
                const f1 = fileIndex + i;
                const r1 = rankIndex + i;
                const f2 = fileIndex + i;
                const r2 = rankIndex - i;
                if (f1 >= 0 && f1 < 8 && r1 >= 0 && r1 < 8) count++;
                if (f2 >= 0 && f2 < 8 && r2 >= 0 && r2 < 8) count++;
            }

            return {
                type: EXERCISE_TYPES.DIAGONALS,
                question: `Quante case ci sono sulle diagonali di ${square} (escluso ${square} stesso)?`,
                answer: count.toString(),
                inputType: 'number',
                explanation: `Ci sono ${count} case sulle diagonali di ${square}`
            };
        }

        function generateTacticalExercise(files, ranks, difficulty, level) {
            // Simplified tactical pattern
            const patterns = [
                'Il Bianco ha Donna in d4, il Nero ha Re in h8 e Torre in h7. La Donna pu√≤ dare scacco?',
                'Cavallo bianco in f3, pedone nero in e5. Il Cavallo pu√≤ catturare il pedone?',
                'Alfiere bianco in c4, pedone nero in f7. L\'Alfiere attacca f7?',
                'Torre bianca in a1, Torre nera in a8. Sono sulla stessa colonna?'
            ];

            const answers = ['s√¨', 's√¨', 's√¨', 's√¨'];
            const pattern = Math.floor(Math.random() * patterns.length);

            return {
                type: EXERCISE_TYPES.TACTICAL,
                question: patterns[pattern],
                answer: answers[pattern],
                options: ['s√¨', 'no'],
                explanation: `La risposta corretta √®: ${answers[pattern]}`
            };
        }

        function generateVariantsExercise(files, ranks, difficulty, level) {
            const moves = level < 40 ? 2 : 3;
            return {
                type: EXERCISE_TYPES.VARIANTS,
                question: `Visualizza: 1.e4 e5 2.Nf3 Nc6${moves === 3 ? ' 3.Bc4 Nf6' : ''}. Dove si trova il Cavallo nero?`,
                answer: moves === 2 ? 'c6' : 'f6',
                inputType: 'text',
                explanation: `Il Cavallo nero √® in ${moves === 2 ? 'c6' : 'f6'}`
            };
        }

        function generateBlindfoldExercise(files, ranks, difficulty, level) {
            return {
                type: EXERCISE_TYPES.BLINDFOLD,
                question: 'Visualizza la posizione iniziale. In quale colonna si trova la Donna bianca?',
                answer: 'd',
                inputType: 'text',
                explanation: 'La Donna bianca inizia nella colonna d (d1)'
            };
        }

        function showExercise() {
            const exercise = exercises[currentExerciseIndex];
            answerSubmitted = false; // Reset for each exercise

            document.getElementById('currentLevel').textContent = currentLevel;
            document.getElementById('currentExercise').textContent = currentExerciseIndex + 1;
            document.getElementById('totalExercises').textContent = EXERCISES_PER_LEVEL;

            let html = `<div class="question">${exercise.question}</div>`;

            if (exercise.showBoard) {
                html += renderChessboard(exercise.answer);
            }

            if (exercise.options) {
                html += '<div class="answers">';
                exercise.options.forEach(option => {
                    html += `<button class="answer-btn" onclick="checkAnswer('${option}')">${option}</button>`;
                });
                html += '</div>';
            } else if (exercise.inputType) {
                html += `
                    <div class="answers">
                        <input type="${exercise.inputType === 'number' ? 'number' : 'text'}"
                               class="input-answer"
                               id="answerInput"
                               placeholder="Risposta..."
                               onkeypress="if(event.key==='Enter') checkInputAnswer()">
                        <button class="submit-btn" onclick="checkInputAnswer()">Conferma</button>
                    </div>
                `;
            }

            html += '<div id="feedback"></div>';

            document.getElementById('exerciseContent').innerHTML = html;
        }

        function renderChessboard(correctSquare) {
            const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];

            let html = '<div class="chessboard">';

            ranks.forEach(rank => {
                files.forEach(file => {
                    const square = file + rank;
                    const fileIndex = files.indexOf(file);
                    const rankNumeric = parseInt(rank);
                    const isLight = (fileIndex + rankNumeric) % 2 === 0;
                    const colorClass = isLight ? 'light' : 'dark';

                    html += `<div class="square ${colorClass}" onclick="checkBoardSquare('${square}')" data-square="${square}"></div>`;
                });
            });

            html += '</div>';
            return html;
        }

        function checkBoardSquare(square) {
            const exercise = exercises[currentExerciseIndex];
            checkAnswer(square);
        }

        function checkAnswer(answer) {
            // Prevent multiple answer attempts
            if (answerSubmitted) {
                return;
            }

            answerSubmitted = true;
            const exercise = exercises[currentExerciseIndex];
            const isCorrect = answer.toLowerCase() === exercise.answer.toLowerCase();

            // Disable all answer buttons
            document.querySelectorAll('.answer-btn').forEach(btn => {
                btn.disabled = true;
                btn.style.cursor = 'not-allowed';
                btn.style.opacity = '0.6';
            });

            // Disable board squares
            document.querySelectorAll('.square').forEach(square => {
                square.style.cursor = 'not-allowed';
                square.style.pointerEvents = 'none';
            });

            if (isCorrect) {
                correctCount++;
                trackDailyProgress();
            }

            showFeedback(isCorrect, exercise.explanation);
        }

        function checkInputAnswer() {
            // Prevent multiple answer attempts
            if (answerSubmitted) {
                return;
            }

            const input = document.getElementById('answerInput');
            if (!input) return;

            const answer = input.value.trim();
            if (!answer) return;

            // Disable input and submit button
            input.disabled = true;
            input.style.opacity = '0.6';
            const submitBtn = document.querySelector('.submit-btn');
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.style.cursor = 'not-allowed';
                submitBtn.style.opacity = '0.6';
            }

            checkAnswer(answer);
        }

        function showFeedback(isCorrect, explanation) {
            const feedbackDiv = document.getElementById('feedback');
            feedbackDiv.className = `feedback ${isCorrect ? 'correct' : 'incorrect'}`;
            feedbackDiv.innerHTML = `
                ${isCorrect ? '‚úÖ' : '‚ùå'} ${explanation}
                <button class="next-btn" onclick="nextExercise()">
                    ${currentExerciseIndex < EXERCISES_PER_LEVEL - 1 ? 'Prossimo Esercizio' : 'Completa Livello'}
                </button>
            `;
        }

        function nextExercise() {
            currentExerciseIndex++;

            if (currentExerciseIndex >= EXERCISES_PER_LEVEL) {
                completeLevel();
            } else {
                showExercise();
            }
        }

        function completeLevel() {
            const score = Math.round((correctCount / EXERCISES_PER_LEVEL) * 100);
            const totalTime = Math.round((Date.now() - startTime) / 1000);

            saveLevelProgress(currentLevel, score);

            document.getElementById('exerciseContent').style.display = 'none';
            document.getElementById('completionView').style.display = 'block';

            document.getElementById('finalScore').textContent = score + '%';
            document.getElementById('correctAnswers').textContent = `${correctCount}/${EXERCISES_PER_LEVEL}`;
            document.getElementById('totalTime').textContent = totalTime + 's';
        }

        function goHome() {
            document.getElementById('homeView').style.display = 'block';
            document.getElementById('exerciseView').classList.remove('active');
            document.getElementById('footer').style.display = 'block'; // Show reset button on home
            document.getElementById('backButtonTop').style.display = 'none'; // Hide back button
            renderLevelGrid();
            render30DayChallenge();
        }

        // === 30 DAY CHALLENGE FUNCTIONS ===

        function getTodayKey() {
            const today = new Date();
            return `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
        }

        function trackDailyProgress() {
            const today = getTodayKey();
            const dailyData = getDailyData();

            if (!dailyData[today]) {
                dailyData[today] = 0;
            }

            dailyData[today]++;
            localStorage.setItem('visichess_daily_progress', JSON.stringify(dailyData));
        }

        function getDailyData() {
            const data = localStorage.getItem('visichess_daily_progress');
            return data ? JSON.parse(data) : {};
        }

        function getLast30Days() {
            const days = [];
            const today = new Date();

            for (let i = 29; i >= 0; i--) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);
                const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                days.push({
                    key: key,
                    label: `${day}/${month}`,
                    value: 0
                });
            }

            return days;
        }

        function calculateStreaks(dailyData, last30Days) {
            let currentStreak = 0;
            let bestStreak = 0;
            let tempStreak = 0;

            // Calculate current streak from today backwards
            const today = new Date();
            for (let i = 0; i < 365; i++) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);
                const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;

                if (dailyData[key] && dailyData[key] > 0) {
                    currentStreak++;
                } else {
                    break;
                }
            }

            // Calculate best streak ever
            const allDates = Object.keys(dailyData).sort();
            for (let i = 0; i < allDates.length; i++) {
                if (dailyData[allDates[i]] > 0) {
                    tempStreak++;
                    bestStreak = Math.max(bestStreak, tempStreak);
                } else {
                    tempStreak = 0;
                }
            }

            // Count active days in last 30 days
            const activeDays = last30Days.filter(day => dailyData[day.key] > 0).length;

            // Count total correct answers in last 30 days
            const totalCorrect = last30Days.reduce((sum, day) => sum + (dailyData[day.key] || 0), 0);

            return { currentStreak, bestStreak, activeDays, totalCorrect };
        }

        function render30DayChallenge() {
            const dailyData = getDailyData();
            const last30Days = getLast30Days();

            // Populate with actual data
            last30Days.forEach(day => {
                day.value = dailyData[day.key] || 0;
            });

            // Find max value for scaling
            const maxValue = Math.max(...last30Days.map(d => d.value), 1);

            // Render chart
            const chartContainer = document.getElementById('challengeChart');
            chartContainer.innerHTML = last30Days.map(day => {
                const height = day.value > 0 ? Math.max(10, (day.value / maxValue) * 100) : 5;
                const className = day.value > 0 ? 'day-bar' : 'day-bar empty';
                return `
                    <div class="${className}" style="height: ${height}%">
                        <div class="day-bar-tooltip">
                            ${day.label}<br>
                            ${day.value} risposte
                        </div>
                    </div>
                `;
            }).join('');

            // Calculate and render stats
            const stats = calculateStreaks(dailyData, last30Days);
            document.getElementById('currentStreak').textContent = stats.currentStreak;
            document.getElementById('bestStreak').textContent = stats.bestStreak;
            document.getElementById('totalDays').textContent = stats.activeDays;
            document.getElementById('totalCorrect').textContent = stats.totalCorrect;
        }

        function resetAllProgress() {
            if (confirm('Sei sicuro di voler resettare tutti i risultati? Questa azione non pu√≤ essere annullata.')) {
                // Clear all level progress from sessionStorage
                for (let i = 1; i <= 64; i++) {
                    sessionStorage.removeItem(`level_${i}`);
                }

                // Clear daily progress from localStorage
                localStorage.removeItem('visichess_daily_progress');

                // Refresh the UI
                renderLevelGrid();
                render30DayChallenge();

                alert('Tutti i risultati sono stati resettati!');
            }
        }
    </script>
</body>
</html>
